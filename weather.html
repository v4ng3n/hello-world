<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Weather Forecast</title>
  <style>
    body { font-family: sans-serif; background: #f5f5f5; margin: 0; }
    nav { background: #333; padding: 1em; }
    nav a { color: white; margin-right: 1em; text-decoration: none; font-weight: bold; }
    main { padding: 2em; max-width: 800px; margin: auto; }
    select { font-size: 1em; margin-bottom: 1em; padding: 0.3em; }
    .day { background: white; border-radius: 8px; padding: 1em; margin-bottom: 1.5em; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    .hour, .interval { display: flex; align-items: center; gap: 1em; margin: 0.4em 0; }
    .hour img, .interval img { width: 28px; height: 28px; }
    .toggle-btn { margin-top: 1em; font-size: 0.9em; color: #007BFF; cursor: pointer; background: none; border: none; padding: 0; }
  </style>
</head>
<body>
  <nav>
    <a href="#">Home</a>
    <a href="#">Weather</a>
  </nav>
  <main>
    <h1>Weather Forecast</h1>
    <label for="location">Select location:</label>
    <select id="location">
      <option value="bergen">Bergen</option>
      <option value="aalborg">Aalborg</option>
      <option value="hormested">Hørmested</option>
      <option value="vojens">Vojens</option>
    </select>
    <div id="forecast">Loading...</div>
  </main>
  <script>
    const locations = {
      bergen: { lat: 60.3913, lon: 5.3221, tzOffset: 1 },
      aalborg: { lat: 57.0488, lon: 9.9217, tzOffset: 1 },
      hormested: { lat: 57.528, lon: 10.139, tzOffset: 1 },
      vojens: { lat: 55.25, lon: 9.3, tzOffset: 1 }
    };

    const weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

    async function fetchForecast(lat, lon) {
      const res = await fetch(`https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=${lat}&lon=${lon}`, {
        headers: { "User-Agent": "weather.v4ng3n.org" }
      });
      const data = await res.json();
      return data.properties.timeseries;
    }

    function formatHour(date) {
      return String(date.getHours()).padStart(2, '0');
    }

    function formatDate(date) {
      return `${String(date.getDate()).padStart(2, '0')}-${String(date.getMonth()+1).padStart(2, '0')}-${date.getFullYear()}`;
    }

    function buildForecast(days) {
      const container = document.getElementById('forecast');
      container.innerHTML = '';

      days.forEach(({ dateKey, dateObj, entries }, index) => {
        const div = document.createElement('div');
        div.className = 'day';
        const weekday = weekdays[dateObj.getDay()];
        const label = index === 0 ? 'Today' : index === 1 ? 'Tomorrow' : 'Day after tomorrow';

        const title = document.createElement('h3');
        title.textContent = `${weekday} – ${label} (${formatDate(dateObj)})`;
        div.appendChild(title);

        const summaryDiv = document.createElement('div');
        const hourlyDiv = document.createElement('div');
        hourlyDiv.style.display = 'none';

        const intervals = [[0,6],[6,12],[12,18],[18,24]];
        intervals.forEach(([start, end]) => {
          const block = entries.filter(e => e.date.getHours() >= start && e.date.getHours() < end);
          if (block.length > 0) {
            const avgTemp = Math.round(block.reduce((sum, b) => sum + b.temp, 0) / block.length);
            const avgWind = Math.round(block.reduce((sum, b) => sum + b.wind, 0) / block.length);
            const totalRain = block.reduce((sum, b) => sum + b.rain, 0).toFixed(1);
            const icon = block[Math.floor(block.length / 2)].symbol;

            const interval = document.createElement('div');
            interval.className = 'interval';
            interval.innerHTML = `<img src="https://api.met.no/images/weathericons/svg/${icon}.svg">
              <div><strong>${String(start).padStart(2,'0')}–${String(end % 24).padStart(2,'0')}</strong> – ${avgTemp}°C, ${totalRain} mm, ${avgWind} m/s</div>`;
            summaryDiv.appendChild(interval);
          }
        });

        let lastHour = null;
        let buffer = [];
        const flushBuffer = (startHour, endHour, data) => {
          if (startHour === 23 && endHour === 24) {
            endHour = null; // Show just 23 without range
          }
          const avgTemp = Math.round(data.reduce((sum, b) => sum + b.temp, 0) / data.length);
          const avgWind = Math.round(data.reduce((sum, b) => sum + b.wind, 0) / data.length);
          const totalRain = data.reduce((sum, b) => sum + b.rain, 0).toFixed(1);
          const icon = data[Math.floor(data.length / 2)].symbol;
          const intervalDiv = document.createElement('div');
          intervalDiv.className = 'hour';
          const label = endHour === null ? `${String(startHour).padStart(2,'0')}` : `${String(startHour).padStart(2,'0')}–${String(endHour).padStart(2,'0')}`;
          intervalDiv.innerHTML = `<img src="https://api.met.no/images/weathericons/svg/${icon}.svg">
            <div><strong>${label}</strong> – ${avgTemp}°C, ${totalRain} mm, ${avgWind} m/s</div>`;
          hourlyDiv.appendChild(intervalDiv);
        };

        for (let i = 0; i < entries.length; i++) {
          const e = entries[i];
          const currentHour = e.date.getHours();

          if (lastHour !== null && (currentHour - lastHour > 1 || currentHour <= lastHour)) {
            if (buffer.length > 0) {
              flushBuffer(buffer[0].date.getHours(), buffer[buffer.length - 1].date.getHours() + 1, buffer);
              buffer = [];
            }
          }

          if (i + 1 < entries.length && entries[i + 1].date.getHours() - currentHour === 1) {
            const hourDiv = document.createElement('div');
            hourDiv.className = 'hour';
            hourDiv.innerHTML = `<img src="https://api.met.no/images/weathericons/svg/${e.symbol}.svg">
              <div><strong>${formatHour(e.date)}</strong> – ${e.temp}°C, ${e.rain} mm, ${e.wind} m/s</div>`;
            hourlyDiv.appendChild(hourDiv);
          } else {
            buffer.push(e);
          }

          lastHour = currentHour;
        }
        if (buffer.length > 0) {
          const last = buffer[buffer.length - 1];
          const startHour = buffer[0].date.getHours();
          const endHour = last.date.getHours();
          if (startHour === endHour) {
            flushBuffer(startHour, null, buffer);
          } else {
            flushBuffer(startHour, endHour + 1, buffer);
          }
        }

        const toggle = document.createElement('button');
        toggle.className = 'toggle-btn';
        toggle.textContent = 'Detailed view';
        toggle.onclick = () => {
          const showDetail = hourlyDiv.style.display === 'none';
          summaryDiv.style.display = showDetail ? 'none' : 'block';
          hourlyDiv.style.display = showDetail ? 'block' : 'none';
          toggle.textContent = showDetail ? 'Hide details' : 'Detailed view';
        };

        div.appendChild(summaryDiv);
        div.appendChild(hourlyDiv);
        div.appendChild(toggle);
        container.appendChild(div);
      });
    }

    async function updateForecast() {
      const loc = document.getElementById('location').value;
      const { lat, lon, tzOffset } = locations[loc];
      const rawData = await fetchForecast(lat, lon);

      const grouped = {};
      rawData.forEach(entry => {
        const utc = new Date(entry.time);
        const local = new Date(utc.getTime() + tzOffset * 60 * 60 * 1000);
        const dateKey = `${local.getFullYear()}-${String(local.getMonth() + 1).padStart(2, '0')}-${String(local.getDate()).padStart(2, '0')}`;
        if (!grouped[dateKey]) grouped[dateKey] = [];
        grouped[dateKey].push({
          date: local,
          temp: Math.round(entry.data.instant.details.air_temperature),
          wind: Math.round(entry.data.instant.details.wind_speed || 0),
          rain: entry.data.next_1_hours?.details?.precipitation_amount || 0,
          symbol: entry.data.next_1_hours?.summary?.symbol_code || 'clearsky_day'
        });
      });

      const sortedDays = Object.entries(grouped)
        .sort(([a], [b]) => new Date(a) - new Date(b))
        .slice(0, 3)
        .map(([key, value]) => ({ dateKey: key, dateObj: new Date(key), entries: value }));

      buildForecast(sortedDays);
    }

    document.getElementById('location').addEventListener('change', updateForecast);
    updateForecast();
  </script>
</body>
</html>
