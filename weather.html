<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weather Forecast</title>
  <style>
    body { font-family: sans-serif; background: #f5f5f5; margin: 0; }
    nav { background: #333; padding: 1em; }
    nav a { color: white; margin-right: 1em; text-decoration: none; font-weight: bold; }
    main { padding: 2em; max-width: 800px; margin: auto; }
    select { font-size: 1em; margin-bottom: 1em; padding: 0.3em; }
    .day { background: white; border-radius: 8px; padding: 1em; margin-bottom: 1.5em; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    .hour, .interval { display: flex; align-items: center; gap: 1em; margin: 0.4em 0; }
    .hour img, .interval img { width: 28px; height: 28px; }
    .toggle-btn { margin-top: 1em; font-size: 0.9em; color: #007BFF; cursor: pointer; background: none; border: none; padding: 0; }
  </style>
</head>
<body>
  <nav>
    <a href="#">Home</a>
    <a href="#">Weather</a>
  </nav>
  <main>
    <h1>Weather Forecast</h1>
    <label for="location">Select location:</label>
    <select id="location">
      <option value="bergen">Bergen</option>
      <option value="aalborg">Aalborg</option>
      <option value="hormested">Hørmested</option>
      <option value="vojens">Vojens</option>
    </select>
    <div id="forecast">Loading...</div>
  </main>
  <script>
    const locations = {
      bergen: { lat: 60.3913, lon: 5.3221, tzName: 'Europe/Oslo' },
      aalborg: { lat: 57.0488, lon: 9.9217, tzName: 'Europe/Copenhagen' },
      hormested: { lat: 57.528, lon: 10.139, tzName: 'Europe/Copenhagen' },
      vojens: { lat: 55.25, lon: 9.3, tzName: 'Europe/Copenhagen' }
    };

    const weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

    async function fetchForecast(lat, lon) {
      const res = await fetch(`https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=${lat}&lon=${lon}`, {
        headers: { "User-Agent": "weather.v4ng3n.org" }
      });
      const data = await res.json();
      return data.properties.timeseries;
    }

    function formatHour(date) {
      return String(date.getHours()).padStart(2, '0');
    }

    function formatDate(date) {
      return `${String(date.getDate()).padStart(2, '0')}-${String(date.getMonth()+1).padStart(2, '0')}-${date.getFullYear()}`;
    }

    function getLocalTime(utcDate, tzName) {
      return new Date(new Intl.DateTimeFormat('en-GB', {
        timeZone: tzName,
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
      }).format(utcDate).replace(/(\d{2})\/(\d{2})\/(\d{4}), (\d{2}):(\d{2})/, '$3-$2-$1T$4:$5:00'));
    }

    function buildForecast(days) {
      const forecastDiv = document.getElementById('forecast');
      forecastDiv.innerHTML = '';

      days.forEach(({ dateKey, dateObj, entries }) => {
        const dayDiv = document.createElement('div');
        dayDiv.className = 'day';

        const weekday = weekdays[dateObj.getDay()];
        const today = new Date();
        today.setHours(0,0,0,0);

        let label = weekday;
        if (dateObj.getTime() === today.getTime()) label += ' – Today';
        else if (dateObj.getTime() === today.getTime() + 86400000) label += ' – Tomorrow';
        else if (dateObj.getTime() === today.getTime() + 2 * 86400000) label += ' – Day after tomorrow';
        label += ` (${formatDate(dateObj)})`;

        const header = document.createElement('h3');
        header.textContent = label;
        dayDiv.appendChild(header);

        const content = document.createElement('div');
        content.className = 'content';

        const button = document.createElement('button');
        button.className = 'toggle-btn';
        button.textContent = 'Detailed view';

        let detailed = false;

        const render = () => {
          content.innerHTML = '';
          if (detailed) {
            const startHour = entries[0].date.getHours();
            let lastHour = startHour - 1;
            for (let i = 0; i < entries.length; i++) {
              const { date, temp, rain, wind, symbol } = entries[i];
              const hour = date.getHours();
              if (hour - lastHour > 1 && hour - lastHour < 23) {
                const label = `${String(lastHour).padStart(2, '0')}–${String(hour).padStart(2, '0')}`;
                const avg = entries.slice(i - 1, i + 1).reduce((acc, e) => {
                  acc.temp += e.temp;
                  acc.rain += e.rain;
                  acc.wind += e.wind;
                  return acc;
                }, { temp: 0, rain: 0, wind: 0 });
                const div = document.createElement('div');
                div.className = 'interval';
                div.innerHTML = `<strong>${label}</strong> – ${Math.round(avg.temp/2)}°C, ${avg.rain.toFixed(1)} mm, ${Math.round(avg.wind/2)} m/s`;
                content.appendChild(div);
              }
              const div = document.createElement('div');
              div.className = 'hour';
              const icon = `https://api.met.no/images/weathericons/svg/${symbol}.svg`;
              div.innerHTML = `<img src="${icon}" alt=""> <strong>${formatHour(date)}</strong> – ${temp}°C, ${rain} mm, ${wind} m/s`;
              content.appendChild(div);
              lastHour = hour;
            }
          } else {
            for (let blockStart = 0; blockStart < 24; blockStart += 6) {
              const blockEnd = blockStart + 6;
              const block = entries.filter(e => {
                const h = e.date.getHours();
                return h >= blockStart && h < blockEnd;
              });
              if (block.length) {
                const avg = block.reduce((acc, e) => {
                  acc.temp += e.temp;
                  acc.rain += e.rain;
                  acc.wind += e.wind;
                  return acc;
                }, { temp: 0, rain: 0, wind: 0 });
                const icon = `https://api.met.no/images/weathericons/svg/${block[0].symbol}.svg`;
                const div = document.createElement('div');
                div.className = 'interval';
                div.innerHTML = `<img src="${icon}" alt=""> <strong>${String(blockStart).padStart(2, '0')}–${String(blockEnd).padStart(2, '0')}</strong> – ${Math.round(avg.temp/block.length)}°C, ${avg.rain.toFixed(1)} mm, ${Math.round(avg.wind/block.length)} m/s`;
                content.appendChild(div);
              }
            }
          }
        };

        button.onclick = () => {
          detailed = !detailed;
          button.textContent = detailed ? 'Hide details' : 'Detailed view';
          render();
        };

        render();
        dayDiv.appendChild(button);
        dayDiv.appendChild(content);
        forecastDiv.appendChild(dayDiv);
      });
    }

    async function updateForecast() {
      const loc = document.getElementById('location').value;
      const { lat, lon, tzName } = locations[loc];
      const rawData = await fetchForecast(lat, lon);

      const grouped = {};
      rawData.forEach(entry => {
        const utc = new Date(entry.time);
        const local = getLocalTime(utc, tzName);
        const dateKey = `${local.getFullYear()}-${String(local.getMonth() + 1).padStart(2, '0')}-${String(local.getDate()).padStart(2, '0')}`;
        if (!grouped[dateKey]) grouped[dateKey] = [];
        grouped[dateKey].push({
          date: local,
          temp: Math.round(entry.data.instant.details.air_temperature),
          wind: Math.round(entry.data.instant.details.wind_speed || 0),
          rain: entry.data.next_1_hours?.details?.precipitation_amount || 0,
          symbol: entry.data.next_1_hours?.summary?.symbol_code || 'clearsky_day'
        });
      });

      const sortedDays = Object.entries(grouped)
        .sort(([a], [b]) => new Date(a) - new Date(b))
        .slice(0, 3)
        .map(([key, value]) => ({ dateKey: key, dateObj: new Date(key), entries: value }));

      buildForecast(sortedDays);
    }

    document.getElementById('location').addEventListener('change', updateForecast);
    updateForecast();
  </script>
</body>
</html>
